# -*- coding: utf-8 -*-
"""AInstrument-1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1p3lucQJED5POKnGJrr-GBt-xmjam2TAd
"""

print('Installing from pip package...')
!pip install flask-ngrok
!pip install -U flask-cors
!pip install pyrebase
!pip install librosa
!pip install spleeter
# !pip install --upgrade tensorflow

# %tensorflow_version 2.x
import tensorflow.compat.v2 as tf
import copy
import os
import time
import json
# import crepe
# import ddsp
# import ddsp.training
# import gin
import librosa
import numpy as np
import pickle
# import tensorflow_datasets as tfds
import spleeter
from scipy.io import wavfile
from tqdm import tqdm
import warnings
from google.colab import files
warnings.filterwarnings("ignore")

from flask import Flask, request, jsonify, Response, send_file, make_response
from flask_cors import CORS
from flask_ngrok import run_with_ngrok
import ast 
import pyrebase
import requests
import json
# from ddsp.colab.colab_utils import (
#     auto_tune, detect_notes, fit_quantile_transform, 
#     get_tuning_factor, download, play, record, 
#     specplot, upload, DEFAULT_SAMPLE_RATE, audio_bytes_to_np)

tf.test.gpu_device_name()

class VocalExtraction:
    def __init__(self,  song, songName):
        self.song = song
        self.songName = songName
        self.destinationPath = ''
        self.extractedDestinationPath = ''



    def extractVocal(self):
        print("Extracting Vocals......")
        stream = os.popen('spleeter separate -p spleeter:2stems -o output '+  self.song)
        output = stream.read()
        print(output)
        print('Vocals are Extracted!!!!!!')
        self.trimExtractedVocal()
    
    def trimExtractedVocal(self):
        print('Trimming the extracted vocals.....')
        self.extractedDestinationPath = '/content/output/'+self.songName+'/vocals.wav'
        samplingFrequency, signalData = wavfile.read(self.extractedDestinationPath)
        songData = []
        for i in tqdm(signalData):
            if abs(i[0])+abs(i[1])>20:
                songData.append(i)
        songData = np.array(songData)
        songData = songData.astype(np.int16)
        uploadTime = time.time()
        os.makedirs('/content/extractedVocals/'+str(uploadTime))
        self.destinationPath = '/content/extractedVocals/'+str(uploadTime)+"/"+self.songName+'.wav'
        wavfile.write(self.destinationPath, samplingFrequency, songData)
        print('Module 1 Completed!!!!!')


def main():
    songName = input('Please enter the song name\n')
    song = './Songs/'+songName+'.mp3'
    obj = VocalExtraction(song, songName)
    # obj.extractVocal()
    obj.trimExtractedVocal()

# if __name__ == "__main__":
#     main()

firebaseConfig = {
    "apiKey": "AIzaSyAcbBkzH2YnTPVyDhKGjeA7EFAQf3wNTeE",
    "authDomain": "ainstrument-a03f0.firebaseapp.com",
    "databaseURL": "https://ainstrument-a03f0-default-rtdb.firebaseio.com",
    "storageBucket": "ainstrument-a03f0.appspot.com",
}
serverURL = "http://d60b61fb3dde.ngrok.io"

app = Flask(__name__)
CORS(app)

try:
  uploads_dir = '/content/uploadedSongs'
  os.makedirs(uploads_dir)
except:
  print("uploads_dir exixts")

try:
  extract_dir = '/content/extractedVocals'
  os.makedirs(extract_dir)
except:
  print("extract_dir exixts")

@app.route('/',methods=['GET'])
def home():
    auth = firebase.auth()
    idToken = request.headers['auth']
    print(idToken)
    return jsonify({'response':'Flask Api setup working','success':1}) , 200

@app.route('/api/v1/extractVocal', methods=['POST'])
def extract():
    auth = firebase.auth()
    songName = request.form['songName']
    song = request.files['audio']
    print("request Received...............")

    # extract = request.form.get('extract')
    extract = True
    uploadTime = time.time()
    os.makedirs(uploads_dir+"/"+str(uploadTime))
    songPath = os.path.join(uploads_dir, str(uploadTime), song.filename)
    instrument = request.form['instrument']
    idToken = request.headers['auth']
    
    try:
      res = auth.get_account_info(idToken)
      print(res)
      userUID = res.get("users")[0].get("localId")
    except requests.exceptions.HTTPError as error:
      error = json.loads(error.args[1])
      errorMessage = error.get("error").get("message")
      statusCode = error.get("error").get("code")
      return make_response(
                jsonify(
                    {
                        "message":errorMessage,
                        "success":0
                    }
                ), 200
            )

    
    try:
        song.save(songPath)
        print("Song saved")
    except:
        print('File exists')
    try:
        if extract:
          print("Vocal")
          vocalObj = VocalExtraction(songPath, songName)
          vocalObj.extractVocal()
          path_to_file = vocalObj.destinationPath
        else:
          # Handle here without extracting
          path_to_file = songPath
        
        url = serverURL + "/convertSong"

        files = {'song': open(path_to_file,'rb')}
        values = {'songName': songName, 'instrument':instrument, 'idToken':idToken, 'userUID':userUID}

        r = requests.post(url, files=files, data=values)
        # print(r.text)
        print("Response Received...............")
        print(r)
        print(r.json())
        result = r.json()
        print(type(result))
        # result = ast.literal_eval(result)
        print(result["success"])
        if result["success"] == 1:
          return make_response(
            jsonify(
                {   "success" : 1,                    
                    "message": result["message"],
                    "data": result["data"]}
              ), 
              200)
        else:
          return make_response(
            jsonify(
                {"message":"Could not be processed pleae try again later", "success": 0}
            ), 
            200)
        
    except:
        return make_response(
            jsonify(
                {"message":"Could not be processed pleae try again later", "success": 0}
            ), 
            200)

@app.route('/api/v1/getProfileDetails', methods=['GET'])
def getProfile():
    idToken = request.headers['auth']
    auth = firebase.auth()
    try:
      res = auth.get_account_info(idToken)
      userUID = res.get("users")[0].get("localId")
    except requests.exceptions.HTTPError as error:
      error = json.loads(error.args[1])
      errorMessage = error.get("error").get("message")
      statusCode = error.get("error").get("code")
      return make_response(
                jsonify(
                    {
                        "message":errorMessage,
                        "success":0
                    }
                ), 200
            )
    try:
      db = firebase.database()
      userData = db.child("users").child(userUID).get(idToken)
      print(userData.val())
      return jsonify({"success":1, "message": "Data fetched succesfully", "data": userData.val()})
    except requests.exceptions.HTTPError as error:
      error = json.loads(error.args[1])
      return jsonify({"success":0, "message": error.get("error")})

    print(users.val())

@app.route('/api/v1/getUsers',methods=['GET'])
def getUsers():
    db = firebase.database()
    users = db.child("users").get()
    print(users.val())
    return jsonify(users.val())

@app.route('/api/v1/signin-user',methods=['POST'])
def signInUser():
    dataReceived = request.get_json()
    email = dataReceived.get("email")
    password = dataReceived.get("password")

    auth = firebase.auth()

    try:
        user = auth.sign_in_with_email_and_password(email, password)
        res = auth.get_account_info(user.get("idToken"))
        print("Res ",res)

        if res.get("users")[0].get("emailVerified"):
            return make_response(
            jsonify(
                {
                    "message":"Logged In successfully",
                    "data":{
                        "userUID": user.get("localId"),
                        "token": user.get("idToken"),
                        "email": user.get("email")
                    },
                    "success":1
                }
            ), 200)
        else:
            return make_response(
            jsonify(
                {
                    "message":"Please Verify email Address to login",
                    "success":0
                }
            ), 200)

    except requests.exceptions.HTTPError as error:
            error = json.loads(error.args[1])
            errorMessage = error.get("error").get("message")
            statusCode = error.get("error").get("code")
            if errorMessage == None:
                errorMessage = error.get("error")
            return make_response(
                jsonify(
                    {
                        "message":errorMessage,
                        "success":0
                    }
                ), 200
            )




@app.route('/api/v1/create-user',methods=['POST'])
def createUser():
    dataReceived = request.get_json()

    name = dataReceived.get("name")
    email = dataReceived.get("email")
    password = dataReceived.get("password")
    confirmPass = dataReceived.get("confirmPass")
   
    if password != confirmPass :
        return jsonify(
                {
                    "message":"Passwords do not match",
                    "success":0
                }
            ), 200

    auth = firebase.auth()

    try:
        user = auth.create_user_with_email_and_password(email, password)
        print(user)
        try:
            db = firebase.database()
            auth.send_email_verification(user['idToken'])
            data = {
                "name": name,
                "email": email
            }
            _ = db.child("users").child(user["localId"]).set(data, user["idToken"])
            return jsonify(
                {
                    "message":"Verification Link has been sent to the above email",
                    "success":1
                }
            ), 200
        except requests.exceptions.HTTPError as error:
            error = json.loads(error.args[1])
            errorMessage = error.get("error").get("message")
            statusCode = error.get("error").get("code")
            return make_response(
            jsonify(
                {
                    "message":errorMessage,
                    "success":0
                }
            ), 200
            )

    except requests.exceptions.HTTPError as error:
        print("------------- ",type(error))
        error = json.loads(error.args[1])
        errorMessage = error.get("error").get("message")
        statusCode = error.get("error").get("code")
        return make_response(
            jsonify(
                {
                    "message":errorMessage,
                    "success":0
                }
            ), 200
        )


if __name__ == "__main__":
    firebase = pyrebase.initialize_app(firebaseConfig)
    run_with_ngrok(app)
    app.run()

x = "{'data': {'extractedSongUrl': 'https://firebasestorage.googleapis.com/v0/b/ainstrument-a03f0.appspot.com/o/uploadedSongs%2F1613816971.924688%2Fkabira.wav?alt=media&token=eyJhbGciOiJSUzI1NiIsImtpZCI6IjYxMDgzMDRiYWRmNDc1MWIyMWUwNDQwNTQyMDZhNDFkOGZmMWNiYTgiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vYWluc3RydW1lbnQtYTAzZjAiLCJhdWQiOiJhaW5zdHJ1bWVudC1hMDNmMCIsImF1dGhfdGltZSI6MTYxMzgxNDUxNywidXNlcl9pZCI6IlJUSkFkZnNBTkJVZG1jNk1NWDBZNHBoYVVDSTMiLCJzdWIiOiJSVEpBZGZzQU5CVWRtYzZNTVgwWTRwaGFVQ0kzIiwiaWF0IjoxNjEzODE0NTE3LCJleHAiOjE2MTM4MTgxMTcsImVtYWlsIjoiYWxpYWJiYXNyaXp2aTc3N0BnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiZmlyZWJhc2UiOnsiaWRlbnRpdGllcyI6eyJlbWFpbCI6WyJhbGlhYmJhc3JpenZpNzc3QGdtYWlsLmNvbSJdfSwic2lnbl9pbl9wcm92aWRlciI6InBhc3N3b3JkIn19.AjbvKHhvsmvWMhYNAWJpvUX3I4oOmqVP_FnVYKRaaDeokntKsLM0RF8I8LBKVEMj83CBLp95oQ6m7Z3rmYvpalYt88CLN3O3cR_mizqNiuttmtsy4ugoK9IzEU86MWjqxEANE3ElZHBTkAd5teYb2yiWA13IKOzxayIlzMhRXYeZrLToql97RkJEh3UOkcv8mpLuISBgu4DiNl01Itjm0JeGfux4X6cJULdhqJ1GTeomIxg6sF4liO5uvvzPe00L0eeVKBytEMfIKm5EJUQQccOYooKdroz-0cgjbLHwbOMb5JrhOFeNZ1XN-0iRpo2IZB0E6eKQLKOchQKmSE9rXA'}, 'message': 'Extraction and saved succesfully', 'success': 1}"

y = json.dumps(x)

y = json.loads(y)
type(y)

import json

x =  '{ "name":"John", "age":30, "city":"New York"}'

# parse x:
y = json.loads(x)

type(y)

import ast 
res = ast.literal_eval(x)

type(res["success"])

